<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
      integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
<style>
    .links line {
        stroke: #999;
        stroke-opacity: 0.6;
        stroke-width: 5px;
    }

    .links line.selected {
        stroke: #28a745;
    }

    .links line.disabled {
        stroke: #dc3545;
    }

    .links line.infected-forward {
        marker-end: url(#arrow);
        stroke: #212529;
        stroke-width: 3px;
        orient: auto;
    }
    .links line.infected-backwards {
        marker-start: url(#arrow);
        stroke: #212529;
        stroke-width: 3px;
        orient: auto;
    }

    .nodes circle {
        stroke-width: 3px;
    }

    .axis-hline {
        marker-end: url(#arrow);
        stroke: #212529;
        stroke-width: 3px;
        orient: auto;
    }

    #graph {
        width: 100%;
        height: 500px;
        margin: auto;
    }
</style>

<body onload="initialize()">
<div class="container">
    <div class="row">
        <div class="col-md-12">
            <div id="graph"></div>
        </div>
    </div>
    <div class="row" id="transitions">
        <button type="button" class="col-md-6 btn btn-primary" onclick="updateState()" id="updateButton" disabled>Next
            step
        </button>
        <label for="timestep" class="col-form-label col-md-2">Timestep:</label>
        <input type="range" value=3100 min=100 max=3100 step=100 class="form-control col-md-3" id="timestep" />
        <label class="col-md-1 col-form-label" id="timestepDisplay">manual</label>
    </div>
    <div class="row" id="initialization">
        <button type="button" class="col-md-6 btn btn-primary" onclick="restart()">Initialize weights</button>
        <label for="greens" class="col-form-label col-sm-2">Initial #greens:</label>
        <input type="range" value=1 min=0 max=5 step=1 class="form-control col-sm-3" id="greens" />
        <label class="col-sm-1 col-form-label" id="greensDisplay">1</label>
    </div>
</div>
</div>
<script src="https://d3js.org/d3.v5.js"></script>
<script>
    // OPTIONS:
    var directed = false;
    var nNodes = 5;
    var nPos = 1;
    var toyExample = [
        [0, 1],
        [0, 2],
        [0, 4],
        [1, 2],
        [2, 3],
    ];
    var model = "toy example";
    var erdosRenyiProb = 3/(nNodes-1);

    // Time between states, 3100 denotes 'manual'
    var timestep = 3100;

    var id = "graph";
    var container = document.getElementById(id);
    var width = container.offsetWidth;
    var height = container.offsetHeight;
    var size = width < height ? width : height;

    var nodes = [];
    var xs = [];
    var ys = [];


    var infectingEdge = null;

    var graph = {
        "nodes": [],
        "links": []
    };

    // A function that gives the id of the link/edge.
    var linkId = e => e.source + "-" + e.target;

    // Transforms a node pair to a link with source and target.
    function pair2link(p) {
        return {
            "source": Math.min(p[0], p[1]),
            "target": Math.max(p[0], p[1])
        };
    }

    // Helper functions
    function randomIndex(max,min=0) {
        return min+Math.floor(Math.random()*(max-min));
    }

    function randomElement(a) {
        return a[randomIndex(a.length)];
    }

    function initializeStates() {
        var negNodes = [];
        nodes.forEach(v => {negNodes.push(v);});
        var posNodes = [];
        for (var i = 0; i < nPos; i++) {
            posNodes.push(negNodes.splice(Math.floor(Math.random()*negNodes.length),1)[0]);
        }
        negNodes.forEach(i => {
            graph.nodes[i].state = false;
        });
        posNodes.forEach(i => {
            graph.nodes[i].state = true;
        });
    }

    // Perform one step of the voting dynamics
    function updateState() {
        // Choose a node uniformly at random
        var source = randomElement(graph.nodes);
        // Choose a neighbor uniformly at random
        var target = graph.nodes[randomElement(source.neighbors)];
        infectingEdge = [source.name,target.name];
        if (source.state != target.state) {
            console.log(target.name+" got infected by "+source.name);
        }
        target.state = source.state;
        updateGraph();
    }

    // Given a d3 selector, this initializes a line for each (enter-) element.
    function initLinks(selector) {
        var links = selector.append("line")
            .attr("id", linkId)
            .attr("x1", e => graph.nodes[e.source].x)
            .attr("y1", e => graph.nodes[e.source].y)
            .attr("x2", e => graph.nodes[e.target].x)
            .attr("y2", e => graph.nodes[e.target].y);
        return links;
    }



    var svg;
    var defs;
    var colorScale;
    var colorbar;
    var line1;
    var line2;
    var axisTicks;

    function initContainer() {
        d3.select("input[id=timestep]").on("change", function () {
            timestep=this.value;
            document.getElementById("timestepDisplay").innerHTML = timestep > 3000 ?  "manual" : timestep + "ms";
            setTimer();
        });
        d3.select("input[id=greens]").on("change", function () {
            nPos=this.value;
            document.getElementById("greensDisplay").innerHTML = nPos;
        });
        document.getElementById("greens").max = nNodes;


        if (!d3.select("#" + id + " svg").empty()) {
            return;
        }
        svg = d3.select("#" + id).append("svg")
            .attr("width", width)
            .attr("height", height);
        defs = svg.append("defs");
        defs.append("marker")
            .attr("id","arrow")
            .attr("viewBox","-19 -5 10 10")
            .attr("refX",0)
            .attr("refY",0)
            .attr("markerWidth",4)
            .attr("markerHeight",4)
            .attr("orient","auto-start-reverse")
            .append("path")
            .attr("d", "M-19,-5L-9,0L-19,5")
            .attr("class","arrowHead");
    }

    var d3Nodes;
    var d3Links;
    var selectedLink;

    function createGraph() {
        for (var i = 0; i < nNodes; i++) {
            nodes.push(i);
        }

        // Initialize positions on an oval.
        for (var i = 0; i < nNodes; i++) {
            var angle = Math.PI * (3 * i % 14) / 7.0;
            var x = width * (1 / 2 + Math.cos(angle) / 4);
            var y = height * (1 / 2 + Math.sin(angle) / 4);
            xs.push(x);
            ys.push(y);
        }

        nodes.forEach(i => graph["nodes"].push({
            "name": i,
            "x": xs[i],
            "y": ys[i],
            "neighbors": [],
            "state": false
        }))

        var edges = [];
        if (model=="ER") {
            for (var s=0; s<nNodes-1; s++) {
                for (var t=s+1; t<nNodes; t++) {
                    if (Math.random()<erdosRenyiProb) {
                        edges.push([s,t]);
                    }
                }
            }
        } else { // model=="toy example"
            edges = toyExample;
        }

        edges.forEach(function (e) {
            graph.links.push(pair2link(e))
            graph.nodes[e[0]].neighbors.push(e[1]);
            graph.nodes[e[1]].neighbors.push(e[0]);
        });

        //draw lines for the links
        d3Links = initLinks(svg.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(graph.links)
            .enter());

        //draw circles for the nodes
        d3Nodes = svg.append("g")
            .attr("stroke", "#fff")
            .attr("stroke-width", 1.5)
            .selectAll("circle")
            .data(graph.nodes)
            .join("circle")
            .attr("r", 10);
        d3Nodes = d3Nodes.on("click",v => {v.state = !v.state; updateGraph();});

        d3Links.transition()
            .attr("x1", function (d) {
                return graph.nodes[d.source].x;
            })
            .attr("y1", function (d) {
                return graph.nodes[d.source].y;
            })
            .attr("x2", function (d) {
                return graph.nodes[d.target].x;
            })
            .attr("y2", function (d) {
                return graph.nodes[d.target].y;
            });

    }

    function setTimer() {
        if (typeof(displayID)!="undefined") {
            clearInterval(displayID);
        }
        if (timestep <=3000) {
            displayID = setTimeout(updateState, timestep);
        }
    }

    function restart() {
        initializeStates();
        infectingEdge = null;
        updateGraph();
        document.getElementById("updateButton").disabled = false;
    }

    function updateGraph() {
        // To allow to update color and position separately
        d3Nodes.style("fill", v => v.state ? "green" : "red");
        if (infectingEdge) {
            var iSource = infectingEdge[0];
            var iTarget = infectingEdge[1];
            d3Links.classed("infected-forward", e => (e.source == iSource && e.target == iTarget));
            d3Links.classed("infected-backwards", e => (e.source == iTarget && e.target == iSource));
        } else {
            d3Links.classed("infected-forward", false);
            d3Links.classed("infected-backwards", false);
        }
        setTimer();
    }

    function initialize() {
        initContainer();

        createGraph();
        d3Nodes
            .attr("cx", function (d) {
                return d.x;
            })
            .attr("cy", function (d) {
                return d.y;
            });
        d3Links
            .attr("x1", function (d) {
                return graph.nodes[d.source].x;
            })
            .attr("y1", function (d) {
                return graph.nodes[d.source].y;
            })
            .attr("x2", function (d) {
                return graph.nodes[d.target].x;
            })
            .attr("y2", function (d) {
                return graph.nodes[d.target].y;
            });
    }

</script>
